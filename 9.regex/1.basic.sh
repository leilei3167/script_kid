#!/bin/bash
# 正则表达式识别的特殊字符包括：
# .*[]^${}\+?|()
# 如果需要使用特殊字符,就必须转义,使用\进行转义

# 锚子符: 有两个特殊字符可以用来将模式锁定在数据流中的行首或行尾
# 1.脱字符（^）定义从数据流中文本行的行首开始的模式。如果模式出现在行首之外的位置正则表达式模式则无法匹配
echo "The book store" | sed -n '/^book/p' # 查找不到
echo "Book store" | sed -n '/^Book/p'     # 查找到
# 脱字符会在每个由换行符决定的新数据行的行首检查模式
# 如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了

# 2. 特殊字符美元符（$）定义了行尾锚点。将这个特殊字符放在文本模式之后来指明数据行必须以该文本模式结尾
echo "This is a good book" | sed -n '/book$/p'

# 3.组合锚点 在一些常见情况下，可以在同一行中将行首锚点和行尾锚点组合在一起使用
#
sed '/^$/d' data5 #中间不包含任何数据,代表空行,这是从文本中删除空行的一种方法

# 点字符 . 用于匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字符的位置没有字符，那么模式就不成立
sed -n '/.at/p' data6 # cat hat都能匹配上

# 字符组,点号特殊字符在匹配某个字符位置上的任意字符时很有用,但如果你想要限定待匹配的具体
# 一些字符呢？
# 字符组用于匹配一组字符中的任意一个字符
# 用方括号定义一个字符组,方括号中包含所有希望能够匹配的字符
sed -n '/[CcHh]at/p' data6 # 匹配cat和hat Cat Hat

# 在不太确定某个字符的大小写时，字符组会非常有用

# 可以在单个表达式中用多个字符组,使用多个方括号即可,对应多个字符的位置
sed -n ' /^[0123456789][0123456789][0123456789][0123456789][0123456789]$/p ' data8 # 只匹配5位数字

# 排除型字符 在字符组开头加上^即可,表示不匹配字符组中的任何一个字符,也就是说,这一个位置上的字符不能是字符组中的任何一个字符

# 区间
sed -n '/^[0-9][0-9][0-9][0-9][0-9]$/p' data8 # 匹配单独5位数字
#也适用于字母
sed -n '/^[a-z][a-z][a-z][a-z][a-z]$/p' data8 # 匹配单独5个小写字母

# 还可以在单个字符组指定多个不连续的区间
sed -n '/[a-ch-m]at/p' data6 #该字符组允许区间a~c、h~m中的字母出现在at文本前，但不允许出现d~g的字母

# 特殊字符组
# [[:alpha:]] 匹配任意字母字符，不管是大写还是小写
# [[:alnum:]] 匹配任意字母数字字符0~9、A~Z或a~z
# [[:blank:]] 匹配空格或制表符
# [[:digit:]] 匹配0~9之间的数字
# [[:lower:]] 匹配小写字母字符a~z
# [[:print:]] 匹配任意可打印字符
# [[:punct:]] 匹配标点符号
# [[:space:]] 匹配任意空白字符：空格、制表符、NL、FF、VT和CR
# [[:upper:]] 匹配任意大写字母字符A~Z

# 星号 在字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次
# 如 ie*k 代表i和k之间的e可以出现0次或任意次,ik,ieek,ieeeeeek都能匹配上

# 一个方便的特性是将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量
# 的任意字符。它通常用在数据流中两个可能相邻或不相邻的文本字符串之间
sed -n '/regular.*expression/p'

echo "baeeaeeat" | sed -n '/b[ae]*t/p' # 只要a和e字符以任何组合形式出现在b和t字符之间（就算完全不出现也行），模式就能够匹配
